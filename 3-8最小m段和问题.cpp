// 3-8最小m段和问题.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
#define INT_MAX 2147483647

int main()
{
	int n, m;
	cin >> n >> m;
	/*
	定义二维数组f[n][m],定义n个数被分成m段的和最大值的中最小值
	定义一维数组t[n],用于记录n个序列
	初始化，先考虑一种极端情况，如果m=1,也就是说n个数不分开。
	f[n][m]等于前n个数相加
	例如：n=5,m=1;
	t[5]={1,2,3,4,5}//从下标1开始计数
	f[1][1] =  1
	f[2][1] =  f[1][1] + t[2]=1+2=3
	f[3][1] =  6
	f[4][1] = 10
	f[5][1] = 15
	第一步初始完成

	然后我们再去拓展，如果分成两段呢
	*/
	vector<vector<int>> f(n + 1, vector<int>(m + 1));
	vector<int> t(n + 1);
	for (int i = 1; i <= n; i++)cin >> t[i];
	int i, j, k, temp, maxt;
	for ( i = 1; i <= n; i++)f[i][1] = f[i - 1][1] + t[i];


	for ( j = 2; j <= m; j++) //j表示分成的段数
		for (i = j; i <= n; i++) {//i表示数的个数
			for (k = 1, temp = INT_MAX; k < i; k++) {//temp用于存取f[i][j]最大值中的最小值，k用于去试探
				/*
				比如说，j=2,i=2;也就是说两个数分成两段，1 2要分成两段，
				这时候k的值小于2，k=1，
				f[i][1]-f[k][1]求出的是从第k+1个数到第i个数的和
				f[k][j-1]求出的是从前k个数分成j-1段子序列中的最大值
				我们从二者中找出最大值来，把最小值放到temp里，最后temp放到f[i][j]
				还是上面的那个例子，n=5,m=3
				1 2 3 4 5
				f[1][1] =  1  f[1][2] =  0  f[1][3] =  0
				f[2][1] =  3  f[2][2] =  2  f[2][3] =  0
				f[3][1] =  6  f[3][2] =  3  f[3][3] =  3
				f[4][1] = 10  f[4][2] =  6  f[4][3] =  4
				f[5][1] = 15  f[5][2] =  9  f[5][3] =  6
				分成一段的情况我们已经分析过了，如果分成两段呢？
				如果前两段要分成两段，也就是1 2要分成两段，很简单，
				f[i][1]-f[k][1]=f[2][1]-f[1][1]=3-1=2,
				f[k][j-1]=f[1][1]=1
				这个可能不明显。



				那把前三段分成2段
				k的条件是k=1，k<i;也就是说，k<3;
				k=1时，f[i][1]-f[k][1]=f[3][1]-f[1][1]=6-1=5，
				求出第k+1到i个数的和，也就是第2个数到第三个数的和
				f[k][j-1]=f[1][1],表示前k个数分成j-1段的最大值
				二者去最大
				....
				每次取完最大的都要和temp去比，如果比temp小，就放到temp里面


				最后结果在f[n][m]中
				*/
				maxt = max(f[i][1] - f[k][1], f[k][j - 1]);
				if (temp > maxt)temp = maxt;
			}
			f[i][j] = temp;
		}
	for (int i = 1; i <=n; i++) {
		for (int j = 1; j <=m; j++) {
			printf("f[%d][%d] = %2d  ",i,j, f[i][j]);
		}
		cout << endl;
	}

	cout << f[n][m];
    return 0;
}

